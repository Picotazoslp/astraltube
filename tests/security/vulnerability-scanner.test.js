/**
 * AstralTube v3 - Security Testing & Vulnerability Scanner
 * Comprehensive security testing for extension safety and vulnerability detection
 */

import { chromeMocks, chromeTestUtils } from '../mocks/chrome-api.js';
import { youTubeAPIMocks } from '../mocks/youtube-api.js';
import { domMocks, mockYouTubePage } from '../mocks/dom.js';

// Security Testing Framework
class SecurityTestFramework {
  constructor() {
    this.vulnerabilities = [];
    this.securityChecks = [];
    this.riskLevels = {
      CRITICAL: 4,
      HIGH: 3,
      MEDIUM: 2,
      LOW: 1,
      INFO: 0
    };
    this.cspViolations = [];
    this.contentSecurityPolicy = null;
  }

  async scanForVulnerabilities(element) {
    this.vulnerabilities = [];
    this.securityChecks = [];

    const securityTests = [
      this.scanForXSS.bind(this),
      this.scanForCSRF.bind(this),
      this.scanForInsecureDataHandling.bind(this),
      this.scanForPermissionMisuse.bind(this),
      this.scanForContentSecurityPolicy.bind(this),
      this.scanForInsecureCommunication.bind(this),
      this.scanForDataLeakage.bind(this),
      this.scanForInjectionVulnerabilities.bind(this),
      this.scanForInsecureStorage.bind(this),
      this.scanForPrivacyViolations.bind(this),
      this.scanForTrustedTypes.bind(this),
      this.scanForOriginValidation.bind(this)
    ];

    for (const test of securityTests) {
      try {
        await test(element);
      } catch (error) {
        this.addVulnerability(
          'SECURITY_TEST_ERROR',
          `Security test failed: ${error.message}`,
          'MEDIUM',
          { test: test.name, error: error.message }
        );
      }
    }

    return this.generateSecurityReport();
  }

  async scanForXSS(element) {
    // Check for XSS vulnerabilities in DOM manipulation
    const userInputElements = element.querySelectorAll('input, textarea, [contenteditable]');
    const dynamicContent = element.querySelectorAll('[data-user-content]');
    
    // Check innerHTML usage (potential XSS vector)
    const scripts = Array.from(document.scripts);
    const hasInnerHTMLUsage = scripts.some(script => 
      script.textContent.includes('.innerHTML') && 
      !script.textContent.includes('DOMPurify') &&
      !script.textContent.includes('sanitize')
    );
    
    if (hasInnerHTMLUsage) {
      this.addVulnerability(
        'XSS_INNERHTML',
        'Potential XSS vulnerability: innerHTML usage without sanitization',
        'HIGH',
        { recommendation: 'Use textContent or DOMPurify for sanitization' }
      );
    }

    // Check for dangerous attributes in user-generated content
    dynamicContent.forEach(el => {
      const dangerousAttribs = ['onclick', 'onmouseover', 'onerror', 'onload'];
      dangerousAttribs.forEach(attr => {
        if (el.hasAttribute(attr)) {
          this.addVulnerability(
            'XSS_EVENT_HANDLER',
            `Dangerous event handler in user content: ${attr}`,
            'HIGH',
            { element: el.tagName, attribute: attr }
          );
        }
      });

      // Check for javascript: URLs
      const links = el.querySelectorAll('a[href^="javascript:"]');
      if (links.length > 0) {
        this.addVulnerability(
          'XSS_JAVASCRIPT_URL',
          'javascript: URL found in user content',
          'HIGH',
          { count: links.length }
        );
      }
    });

    // Check for reflected user input
    userInputElements.forEach(input => {
      const value = input.value || input.textContent;
      if (value && value.includes('<script>')) {
        this.addVulnerability(
          'XSS_REFLECTED_INPUT',
          'User input contains script tags',
          'CRITICAL',
          { inputType: input.tagName, value: value.substring(0, 100) }
        );
      }
    });

    this.addSecurityCheck('XSS_SCAN', 'Completed XSS vulnerability scan');
  }

  async scanForCSRF(element) {
    // Check for CSRF protection in forms
    const forms = element.querySelectorAll('form');
    
    forms.forEach(form => {
      const method = form.getAttribute('method')?.toLowerCase();
      const hasCSRFToken = form.querySelector('input[name*="csrf"], input[name*="token"]');
      const action = form.getAttribute('action');
      
      if (method === 'post' && !hasCSRFToken && action && !action.startsWith('#')) {
        this.addVulnerability(
          'CSRF_NO_TOKEN',
          'Form lacks CSRF protection token',
          'MEDIUM',
          { formId: form.id, action }
        );
      }

      // Check for SameSite cookie usage
      const cookieElements = form.querySelectorAll('[data-cookie-name]');
      cookieElements.forEach(el => {
        const cookieName = el.getAttribute('data-cookie-name');
        // In a real implementation, you'd check actual cookie attributes
        this.addSecurityCheck('CSRF_COOKIE_CHECK', `Checked SameSite attribute for ${cookieName}`);
      });
    });

    this.addSecurityCheck('CSRF_SCAN', 'Completed CSRF protection scan');
  }

  async scanForInsecureDataHandling(element) {
    // Check for sensitive data exposure
    const sensitiveDataPatterns = [
      /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/, // Email
      /\b(?:\d{4}[-\s]?){3}\d{4}\b/, // Credit card
      /\b\d{3}-\d{2}-\d{4}\b/, // SSN
      /\b[A-Z0-9]{24,}\b/ // API keys (generic pattern)
    ];

    const textContent = element.textContent || '';
    
    sensitiveDataPatterns.forEach((pattern, index) => {
      if (pattern.test(textContent)) {
        const patternNames = ['EMAIL', 'CREDIT_CARD', 'SSN', 'API_KEY'];
        this.addVulnerability(
          'SENSITIVE_DATA_EXPOSURE',
          `Potential ${patternNames[index]} found in DOM content`,
          'HIGH',
          { pattern: pattern.toString(), type: patternNames[index] }
        );
      }
    });

    // Check localStorage/sessionStorage usage
    const storageUsage = this.checkStorageUsage();
    if (storageUsage.hasUnsafeStorage) {
      this.addVulnerability(
        'INSECURE_STORAGE',
        'Sensitive data may be stored insecurely in localStorage/sessionStorage',
        'MEDIUM',
        storageUsage
      );
    }

    this.addSecurityCheck('DATA_HANDLING_SCAN', 'Completed insecure data handling scan');
  }

  async scanForPermissionMisuse(element) {
    // Check Chrome extension permissions usage
    const manifest = chromeMocks.runtime.getManifest();
    const permissions = manifest.permissions || [];
    const optionalPermissions = manifest.optional_permissions || [];

    // Check for excessive permissions
    const highRiskPermissions = [
      'tabs', 'activeTab', 'webNavigation', 'webRequest', 
      'webRequestBlocking', 'proxy', 'privacy', 'management'
    ];

    const riskyPermissions = permissions.filter(p => highRiskPermissions.includes(p));
    if (riskyPermissions.length > 3) {
      this.addVulnerability(
        'EXCESSIVE_PERMISSIONS',
        'Extension requests excessive high-risk permissions',
        'MEDIUM',
        { permissions: riskyPermissions, total: permissions.length }
      );
    }

    // Check for unused permissions
    const usedPermissions = this.detectPermissionUsage();
    const unusedPermissions = permissions.filter(p => !usedPermissions.includes(p));
    
    if (unusedPermissions.length > 0) {
      this.addVulnerability(
        'UNUSED_PERMISSIONS',
        'Extension declares permissions that appear unused',
        'LOW',
        { unused: unusedPermissions }
      );
    }

    // Check content script host permissions
    const contentScripts = manifest.content_scripts || [];
    contentScripts.forEach(cs => {
      const matches = cs.matches || [];
      const broadMatches = matches.filter(m => m.includes('*://*/*'));
      
      if (broadMatches.length > 0) {
        this.addVulnerability(
          'BROAD_HOST_PERMISSIONS',
          'Content script uses overly broad host permissions',
          'MEDIUM',
          { matches: broadMatches }
        );
      }
    });

    this.addSecurityCheck('PERMISSION_SCAN', 'Completed permission misuse scan');
  }

  async scanForContentSecurityPolicy(element) {
    // Check for CSP implementation
    const metaCSP = element.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const cspContent = metaCSP?.getAttribute('content');

    if (!cspContent) {
      this.addVulnerability(
        'MISSING_CSP',
        'Content Security Policy not implemented',
        'MEDIUM',
        { recommendation: 'Implement CSP to prevent XSS attacks' }
      );
      return;
    }

    // Parse and validate CSP
    const cspDirectives = this.parseCSP(cspContent);
    
    // Check for unsafe directives
    const unsafePatterns = ['unsafe-inline', 'unsafe-eval', '*', 'data:'];
    Object.entries(cspDirectives).forEach(([directive, values]) => {
      values.forEach(value => {
        if (unsafePatterns.includes(value)) {
          this.addVulnerability(
            'UNSAFE_CSP_DIRECTIVE',
            `CSP contains unsafe directive: ${directive} ${value}`,
            'HIGH',
            { directive, value }
          );
        }
      });
    });

    // Check for missing important directives
    const importantDirectives = ['script-src', 'object-src', 'base-uri'];
    importantDirectives.forEach(directive => {
      if (!cspDirectives[directive]) {
        this.addVulnerability(
          'INCOMPLETE_CSP',
          `CSP missing important directive: ${directive}`,
          'MEDIUM',
          { directive }
        );
      }
    });

    this.contentSecurityPolicy = cspDirectives;
    this.addSecurityCheck('CSP_SCAN', 'Completed Content Security Policy scan');
  }

  async scanForInsecureCommunication(element) {
    // Check for insecure HTTP requests
    const links = element.querySelectorAll('a[href^="http:"], img[src^="http:"], script[src^="http:"]');
    if (links.length > 0) {
      this.addVulnerability(
        'INSECURE_HTTP',
        'Resources loaded over insecure HTTP connection',
        'MEDIUM',
        { count: links.length, types: Array.from(new Set(Array.from(links).map(l => l.tagName))) }
      );
    }

    // Check for postMessage usage without origin validation
    const scripts = Array.from(document.scripts);
    const hasPostMessage = scripts.some(script => 
      script.textContent.includes('postMessage') &&
      !script.textContent.includes('origin') &&
      !script.textContent.includes('targetOrigin')
    );

    if (hasPostMessage) {
      this.addVulnerability(
        'UNSAFE_POSTMESSAGE',
        'postMessage usage without proper origin validation',
        'HIGH',
        { recommendation: 'Always validate message origin' }
      );
    }

    // Check for WebSocket usage
    const hasWebSocket = scripts.some(script => 
      script.textContent.includes('WebSocket') &&
      script.textContent.includes('ws://')
    );

    if (hasWebSocket) {
      this.addVulnerability(
        'INSECURE_WEBSOCKET',
        'Insecure WebSocket connection (ws:// instead of wss://)',
        'HIGH',
        { recommendation: 'Use secure WebSocket connections (wss://)' }
      );
    }

    this.addSecurityCheck('COMMUNICATION_SCAN', 'Completed insecure communication scan');
  }

  async scanForDataLeakage(element) {
    // Check for potential data leakage through various channels
    
    // Check for console.log with sensitive data
    const scripts = Array.from(document.scripts);
    const hasConsoleLogging = scripts.some(script => 
      script.textContent.includes('console.log') &&
      (script.textContent.includes('password') || 
       script.textContent.includes('token') ||
       script.textContent.includes('apiKey'))
    );

    if (hasConsoleLogging) {
      this.addVulnerability(
        'DATA_LEAK_CONSOLE',
        'Potential sensitive data logging to console',
        'MEDIUM',
        { recommendation: 'Remove or sanitize console logging in production' }
      );
    }

    // Check for error messages that might leak information
    const errorElements = element.querySelectorAll('.error, .exception, [data-error]');
    errorElements.forEach(el => {
      const errorText = el.textContent.toLowerCase();
      if (errorText.includes('sql') || 
          errorText.includes('database') || 
          errorText.includes('internal server')) {
        this.addVulnerability(
          'INFORMATION_DISCLOSURE',
          'Error message may leak sensitive system information',
          'LOW',
          { errorText: errorText.substring(0, 100) }
        );
      }
    });

    // Check for hidden form fields with sensitive data
    const hiddenInputs = element.querySelectorAll('input[type="hidden"]');
    hiddenInputs.forEach(input => {
      const name = input.name.toLowerCase();
      if (name.includes('password') || name.includes('secret') || name.includes('key')) {
        this.addVulnerability(
          'HIDDEN_SENSITIVE_DATA',
          'Hidden form field contains sensitive data name',
          'MEDIUM',
          { fieldName: name }
        );
      }
    });

    this.addSecurityCheck('DATA_LEAKAGE_SCAN', 'Completed data leakage scan');
  }

  async scanForInjectionVulnerabilities(element) {
    // Check for SQL injection patterns (though less relevant for frontend)
    const inputs = element.querySelectorAll('input, textarea');
    const sqlKeywords = ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'UNION'];
    
    inputs.forEach(input => {
      const value = input.value?.toUpperCase() || '';
      const hasSQLPattern = sqlKeywords.some(keyword => value.includes(keyword));
      
      if (hasSQLPattern) {
        this.addVulnerability(
          'POTENTIAL_SQL_INJECTION',
          'Input contains SQL-like patterns',
          'LOW',
          { inputId: input.id, pattern: value.substring(0, 50) }
        );
      }
    });

    // Check for command injection patterns
    const commandPatterns = [/;\s*rm\s+/, /;\s*cat\s+/, /\|\s*nc\s+/, /&&\s*curl/];
    inputs.forEach(input => {
      const value = input.value || '';
      commandPatterns.forEach(pattern => {
        if (pattern.test(value)) {
          this.addVulnerability(
            'POTENTIAL_COMMAND_INJECTION',
            'Input contains command injection patterns',
            'MEDIUM',
            { inputId: input.id, pattern: pattern.toString() }
          );
        }
      });
    });

    // Check for template injection
    const templatePatterns = [/\{\{.*\}\}/, /\$\{.*\}/, /<%(.*?)%>/];
    inputs.forEach(input => {
      const value = input.value || '';
      templatePatterns.forEach(pattern => {
        if (pattern.test(value)) {
          this.addVulnerability(
            'POTENTIAL_TEMPLATE_INJECTION',
            'Input contains template injection patterns',
            'MEDIUM',
            { inputId: input.id, pattern: pattern.toString() }
          );
        }
      });
    });

    this.addSecurityCheck('INJECTION_SCAN', 'Completed injection vulnerability scan');
  }

  async scanForInsecureStorage(element) {
    // Check for insecure storage patterns
    const storageChecks = this.checkStorageUsage();
    
    // Check for unencrypted sensitive data in storage
    if (storageChecks.sensitiveKeys.length > 0) {
      this.addVulnerability(
        'UNENCRYPTED_SENSITIVE_STORAGE',
        'Sensitive data stored without encryption',
        'HIGH',
        { sensitiveKeys: storageChecks.sensitiveKeys }
      );
    }

    // Check for excessive data retention
    if (storageChecks.storageSize > 5 * 1024 * 1024) { // 5MB
      this.addVulnerability(
        'EXCESSIVE_DATA_STORAGE',
        'Extension stores excessive amount of data',
        'LOW',
        { size: storageChecks.storageSize, recommendation: 'Implement data cleanup' }
      );
    }

    // Check for storage of authentication tokens
    if (storageChecks.hasAuthTokens) {
      this.addVulnerability(
        'INSECURE_TOKEN_STORAGE',
        'Authentication tokens stored in potentially insecure storage',
        'HIGH',
        { recommendation: 'Use Chrome identity API or secure token storage' }
      );
    }

    this.addSecurityCheck('STORAGE_SCAN', 'Completed insecure storage scan');
  }

  async scanForPrivacyViolations(element) {
    // Check for privacy violations
    
    // Check for tracking pixels or analytics without disclosure
    const trackingElements = element.querySelectorAll('img[src*="analytics"], img[src*="track"], script[src*="analytics"]');
    if (trackingElements.length > 0) {
      const hasPrivacyNotice = element.querySelector('.privacy-notice, .privacy-policy, [data-privacy]');
      if (!hasPrivacyNotice) {
        this.addVulnerability(
          'UNDISCLOSED_TRACKING',
          'Tracking elements present without privacy disclosure',
          'MEDIUM',
          { trackingCount: trackingElements.length }
        );
      }
    }

    // Check for collection of personal data
    const personalDataInputs = element.querySelectorAll(
      'input[name*="email"], input[name*="name"], input[name*="phone"], input[name*="address"]'
    );
    
    if (personalDataInputs.length > 0) {
      const hasConsentMechanism = element.querySelector('[data-consent], .consent-checkbox, input[name*="consent"]');
      if (!hasConsentMechanism) {
        this.addVulnerability(
          'MISSING_CONSENT_MECHANISM',
          'Personal data collection without explicit consent mechanism',
          'HIGH',
          { fieldsCount: personalDataInputs.length }
        );
      }
    }

    // Check for data retention policy
    const hasDataRetentionInfo = element.textContent.toLowerCase().includes('data retention') ||
                                 element.querySelector('[data-retention], .retention-policy');
    
    if (personalDataInputs.length > 0 && !hasDataRetentionInfo) {
      this.addVulnerability(
        'MISSING_DATA_RETENTION_POLICY',
        'No data retention policy disclosed for personal data collection',
        'LOW',
        { recommendation: 'Provide clear data retention information' }
      );
    }

    this.addSecurityCheck('PRIVACY_SCAN', 'Completed privacy violation scan');
  }

  async scanForTrustedTypes(element) {
    // Check for Trusted Types implementation
    const scripts = Array.from(document.scripts);
    const hasDOMManipulation = scripts.some(script =>
      script.textContent.includes('.innerHTML') ||
      script.textContent.includes('.outerHTML') ||
      script.textContent.includes('document.write')
    );

    const hasTrustedTypes = scripts.some(script =>
      script.textContent.includes('trustedTypes') ||
      script.textContent.includes('createPolicy')
    );

    if (hasDOMManipulation && !hasTrustedTypes) {
      this.addVulnerability(
        'MISSING_TRUSTED_TYPES',
        'DOM manipulation without Trusted Types protection',
        'MEDIUM',
        { recommendation: 'Implement Trusted Types for DOM manipulation' }
      );
    }

    // Check for eval usage
    const hasEval = scripts.some(script =>
      script.textContent.includes('eval(') ||
      script.textContent.includes('Function(') ||
      script.textContent.includes('setTimeout(') && script.textContent.includes('"')
    );

    if (hasEval) {
      this.addVulnerability(
        'UNSAFE_CODE_EXECUTION',
        'Use of eval() or similar unsafe code execution methods',
        'HIGH',
        { recommendation: 'Avoid eval() and use safer alternatives' }
      );
    }

    this.addSecurityCheck('TRUSTED_TYPES_SCAN', 'Completed Trusted Types scan');
  }

  async scanForOriginValidation(element) {
    // Check for proper origin validation in postMessage handlers
    const scripts = Array.from(document.scripts);
    const messageHandlers = scripts.filter(script =>
      script.textContent.includes('addEventListener') &&
      script.textContent.includes('message')
    );

    messageHandlers.forEach((script, index) => {
      const hasOriginCheck = script.textContent.includes('event.origin') &&
                            (script.textContent.includes('===') || script.textContent.includes('=='));
      
      if (!hasOriginCheck) {
        this.addVulnerability(
          'MISSING_ORIGIN_VALIDATION',
          'postMessage handler lacks proper origin validation',
          'HIGH',
          { handlerIndex: index, recommendation: 'Always validate event.origin' }
        );
      }
    });

    // Check for fetch/XMLHttpRequest origin validation
    const hasNetworkRequests = scripts.some(script =>
      script.textContent.includes('fetch(') ||
      script.textContent.includes('XMLHttpRequest')
    );

    if (hasNetworkRequests) {
      const hasCORSValidation = scripts.some(script =>
        script.textContent.includes('Access-Control') ||
        script.textContent.includes('cors')
      );

      if (!hasCORSValidation) {
        this.addVulnerability(
          'MISSING_CORS_VALIDATION',
          'Network requests without proper CORS validation',
          'MEDIUM',
          { recommendation: 'Implement proper CORS validation' }
        );
      }
    }

    this.addSecurityCheck('ORIGIN_VALIDATION_SCAN', 'Completed origin validation scan');
  }

  // Utility methods
  checkStorageUsage() {
    const sensitiveKeys = [];
    const storageSize = 0;
    let hasAuthTokens = false;
    let hasUnsafeStorage = false;

    // Mock storage analysis - in real implementation would check actual storage
    const mockStorageData = {
      'user_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
      'api_key': 'sk_live_abcd1234',
      'user_email': 'user@example.com',
      'preferences': '{"theme":"dark"}'
    };

    Object.keys(mockStorageData).forEach(key => {
      const lowerKey = key.toLowerCase();
      if (lowerKey.includes('token') || lowerKey.includes('auth') || lowerKey.includes('jwt')) {
        hasAuthTokens = true;
      }
      if (lowerKey.includes('password') || lowerKey.includes('secret') || lowerKey.includes('key')) {
        sensitiveKeys.push(key);
        hasUnsafeStorage = true;
      }
    });

    return {
      sensitiveKeys,
      storageSize: JSON.stringify(mockStorageData).length,
      hasAuthTokens,
      hasUnsafeStorage
    };
  }

  detectPermissionUsage() {
    // Mock permission usage detection
    return ['storage', 'activeTab'];
  }

  parseCSP(cspString) {
    const directives = {};
    const parts = cspString.split(';');
    
    parts.forEach(part => {
      const [directive, ...values] = part.trim().split(/\s+/);
      if (directive) {
        directives[directive] = values;
      }
    });
    
    return directives;
  }

  addVulnerability(type, message, severity, details = {}) {
    this.vulnerabilities.push({
      type,
      message,
      severity,
      riskLevel: this.riskLevels[severity],
      details,
      timestamp: Date.now()
    });
  }

  addSecurityCheck(checkType, message, details = {}) {
    this.securityChecks.push({
      type: checkType,
      message,
      details,
      timestamp: Date.now()
    });
  }

  generateSecurityReport() {
    const vulnerabilitiesByRisk = this.vulnerabilities.reduce((acc, vuln) => {
      if (!acc[vuln.severity]) acc[vuln.severity] = [];
      acc[vuln.severity].push(vuln);
      return acc;
    }, {});

    const totalRiskScore = this.vulnerabilities.reduce((sum, vuln) => sum + vuln.riskLevel, 0);
    const maxRiskScore = this.vulnerabilities.length * this.riskLevels.CRITICAL;
    const securityScore = maxRiskScore > 0 ? Math.max(0, 100 - (totalRiskScore / maxRiskScore) * 100) : 100;

    return {
      timestamp: Date.now(),
      securityScore: Math.round(securityScore),
      riskLevel: this.calculateOverallRiskLevel(),
      summary: {
        totalVulnerabilities: this.vulnerabilities.length,
        critical: vulnerabilitiesByRisk.CRITICAL?.length || 0,
        high: vulnerabilitiesByRisk.HIGH?.length || 0,
        medium: vulnerabilitiesByRisk.MEDIUM?.length || 0,
        low: vulnerabilitiesByRisk.LOW?.length || 0,
        info: vulnerabilitiesByRisk.INFO?.length || 0,
        checksPerformed: this.securityChecks.length
      },
      vulnerabilities: this.vulnerabilities,
      securityChecks: this.securityChecks,
      recommendations: this.generateRecommendations(),
      compliance: {
        owasp: this.checkOWASPCompliance(),
        privacy: this.checkPrivacyCompliance(),
        extensionSecurity: this.checkExtensionSecurityCompliance()
      }
    };
  }

  calculateOverallRiskLevel() {
    const criticalCount = this.vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    const highCount = this.vulnerabilities.filter(v => v.severity === 'HIGH').length;
    
    if (criticalCount > 0) return 'CRITICAL';
    if (highCount > 2) return 'HIGH';
    if (this.vulnerabilities.length > 5) return 'MEDIUM';
    if (this.vulnerabilities.length > 0) return 'LOW';
    return 'SECURE';
  }

  generateRecommendations() {
    const recommendations = [];
    
    // Generate recommendations based on found vulnerabilities
    const vulnTypes = [...new Set(this.vulnerabilities.map(v => v.type))];
    
    if (vulnTypes.includes('XSS_INNERHTML')) {
      recommendations.push('Implement DOMPurify or similar sanitization library');
    }
    if (vulnTypes.includes('MISSING_CSP')) {
      recommendations.push('Implement Content Security Policy headers');
    }
    if (vulnTypes.includes('INSECURE_STORAGE')) {
      recommendations.push('Encrypt sensitive data before storage');
    }
    if (vulnTypes.includes('EXCESSIVE_PERMISSIONS')) {
      recommendations.push('Review and minimize extension permissions');
    }
    
    return recommendations;
  }

  checkOWASPCompliance() {
    const owaspChecks = {
      'A01:2021-Broken Access Control': this.vulnerabilities.filter(v => 
        v.type.includes('PERMISSION') || v.type.includes('ACCESS')).length === 0,
      'A03:2021-Injection': this.vulnerabilities.filter(v => 
        v.type.includes('INJECTION') || v.type.includes('XSS')).length === 0,
      'A05:2021-Security Misconfiguration': this.vulnerabilities.filter(v => 
        v.type.includes('CSP') || v.type.includes('CORS')).length === 0,
      'A06:2021-Vulnerable Components': true, // Would need dependency scanning
      'A07:2021-Identification and Authentication Failures': this.vulnerabilities.filter(v => 
        v.type.includes('TOKEN') || v.type.includes('AUTH')).length === 0
    };
    
    const compliantChecks = Object.values(owaspChecks).filter(Boolean).length;
    const totalChecks = Object.keys(owaspChecks).length;
    
    return {
      score: Math.round((compliantChecks / totalChecks) * 100),
      details: owaspChecks
    };
  }

  checkPrivacyCompliance() {
    const privacyViolations = this.vulnerabilities.filter(v => 
      v.type.includes('PRIVACY') || v.type.includes('TRACKING') || v.type.includes('CONSENT')
    );
    
    return {
      gdprCompliant: privacyViolations.length === 0,
      ccpaCompliant: privacyViolations.length === 0,
      violationsCount: privacyViolations.length
    };
  }

  checkExtensionSecurityCompliance() {
    const extensionViolations = this.vulnerabilities.filter(v => 
      v.type.includes('PERMISSION') || v.type.includes('CSP') || v.type.includes('ORIGIN')
    );
    
    return {
      chromeWebStoreCompliant: extensionViolations.length === 0,
      manifestV3Ready: true, // Would check manifest version specifics
      securityViolations: extensionViolations.length
    };
  }
}

describe('Security Testing & Vulnerability Scanning', () => {
  let securityFramework;

  beforeEach(() => {
    securityFramework = new SecurityTestFramework();
    mockYouTubePage();
  });

  afterEach(() => {
    securityFramework = null;
  });

  describe('XSS Vulnerability Detection', () => {
    test('should detect innerHTML usage without sanitization', async () => {
      const vulnerableHTML = `
        <div id="vulnerable-content">
          <script>
            function updateContent(userInput) {
              document.getElementById('output').innerHTML = userInput;
            }
          </script>
          <div id="output"></div>
        </div>
      `;

      const container = document.createElement('div');
      container.innerHTML = vulnerableHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'XSS_INNERHTML')).toBe(true);
      expect(report.summary.high).toBeGreaterThan(0);

      container.remove();
    });

    test('should detect dangerous event handlers in user content', async () => {
      const maliciousHTML = `
        <div data-user-content="true">
          <p onclick="alert('xss')">Malicious content</p>
          <a href="javascript:alert('xss')">Dangerous link</a>
        </div>
      `;

      const container = document.createElement('div');
      container.innerHTML = maliciousHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      const xssVulns = report.vulnerabilities.filter(v => v.type.startsWith('XSS_'));
      expect(xssVulns.length).toBeGreaterThan(0);

      container.remove();
    });

    test('should pass when proper sanitization is used', async () => {
      const safeHTML = `
        <div id="safe-content">
          <script>
            function updateContent(userInput) {
              document.getElementById('output').textContent = userInput; // Safe
            }
            function updateWithSanitization(userInput) {
              document.getElementById('output2').innerHTML = DOMPurify.sanitize(userInput); // Safe
            }
          </script>
          <div id="output"></div>
          <div id="output2"></div>
        </div>
      `;

      const container = document.createElement('div');
      container.innerHTML = safeHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.filter(v => v.type === 'XSS_INNERHTML').length).toBe(0);

      container.remove();
    });
  });

  describe('CSRF Protection Detection', () => {
    test('should detect forms without CSRF tokens', async () => {
      const formHTML = `
        <form method="post" action="/api/create-playlist">
          <input type="text" name="title" />
          <input type="submit" value="Create" />
        </form>
      `;

      const container = document.createElement('div');
      container.innerHTML = formHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'CSRF_NO_TOKEN')).toBe(true);

      container.remove();
    });

    test('should pass when CSRF token is present', async () => {
      const secureFormHTML = `
        <form method="post" action="/api/create-playlist">
          <input type="hidden" name="csrf_token" value="abc123" />
          <input type="text" name="title" />
          <input type="submit" value="Create" />
        </form>
      `;

      const container = document.createElement('div');
      container.innerHTML = secureFormHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.filter(v => v.type === 'CSRF_NO_TOKEN').length).toBe(0);

      container.remove();
    });
  });

  describe('Content Security Policy Validation', () => {
    test('should detect missing CSP', async () => {
      const container = document.createElement('div');
      container.innerHTML = '<div>Content without CSP</div>';
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'MISSING_CSP')).toBe(true);

      container.remove();
    });

    test('should detect unsafe CSP directives', async () => {
      const unsafeCSPHTML = `
        <meta http-equiv="Content-Security-Policy" 
              content="script-src 'unsafe-inline' 'unsafe-eval' *; object-src *;">
        <div>Content with unsafe CSP</div>
      `;

      const container = document.createElement('div');
      container.innerHTML = unsafeCSPHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'UNSAFE_CSP_DIRECTIVE')).toBe(true);

      container.remove();
    });

    test('should pass with secure CSP', async () => {
      const secureCSPHTML = `
        <meta http-equiv="Content-Security-Policy" 
              content="script-src 'self'; object-src 'none'; base-uri 'self';">
        <div>Content with secure CSP</div>
      `;

      const container = document.createElement('div');
      container.innerHTML = secureCSPHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      const cspViolations = report.vulnerabilities.filter(v => v.type.includes('CSP'));
      expect(cspViolations.length).toBeLessThan(2); // May have missing directive warnings
      expect(report.vulnerabilities.filter(v => v.type === 'UNSAFE_CSP_DIRECTIVE').length).toBe(0);

      container.remove();
    });
  });

  describe('Insecure Communication Detection', () => {
    test('should detect HTTP resources in HTTPS context', async () => {
      const insecureHTML = `
        <img src="http://example.com/image.jpg" />
        <script src="http://example.com/script.js"></script>
        <a href="http://example.com/page.html">Insecure link</a>
      `;

      const container = document.createElement('div');
      container.innerHTML = insecureHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'INSECURE_HTTP')).toBe(true);

      container.remove();
    });

    test('should detect unsafe postMessage usage', async () => {
      const unsafePostMessageHTML = `
        <script>
          window.postMessage('sensitive data', '*');
          window.addEventListener('message', function(event) {
            // No origin validation
            console.log(event.data);
          });
        </script>
      `;

      const container = document.createElement('div');
      container.innerHTML = unsafePostMessageHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'UNSAFE_POSTMESSAGE')).toBe(true);

      container.remove();
    });
  });

  describe('Sensitive Data Detection', () => {
    test('should detect sensitive data exposure in DOM', async () => {
      const sensitiveHTML = `
        <div>
          <p>Contact us at admin@company.com</p>
          <p>API Key: AIzaSyDf3K1h2x9v8w5t4r3e2w1q</p>
          <p>SSN: 123-45-6789</p>
        </div>
      `;

      const container = document.createElement('div');
      container.innerHTML = sensitiveHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'SENSITIVE_DATA_EXPOSURE')).toBe(true);

      container.remove();
    });

    test('should detect insecure storage of sensitive data', async () => {
      const container = document.createElement('div');
      container.innerHTML = '<div>Test content</div>';
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'UNENCRYPTED_SENSITIVE_STORAGE')).toBe(true);

      container.remove();
    });
  });

  describe('Privacy Compliance', () => {
    test('should detect undisclosed tracking', async () => {
      const trackingHTML = `
        <img src="https://analytics.example.com/track.gif" />
        <script src="https://googletagmanager.com/gtag.js"></script>
        <div>No privacy notice</div>
      `;

      const container = document.createElement('div');
      container.innerHTML = trackingHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'UNDISCLOSED_TRACKING')).toBe(true);

      container.remove();
    });

    test('should detect missing consent mechanism', async () => {
      const personalDataHTML = `
        <form>
          <input type="email" name="email" placeholder="Your email" />
          <input type="text" name="name" placeholder="Your name" />
          <input type="tel" name="phone" placeholder="Phone number" />
          <button type="submit">Submit</button>
        </form>
      `;

      const container = document.createElement('div');
      container.innerHTML = personalDataHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'MISSING_CONSENT_MECHANISM')).toBe(true);

      container.remove();
    });

    test('should pass with proper consent mechanism', async () => {
      const compliantHTML = `
        <form>
          <input type="email" name="email" placeholder="Your email" />
          <input type="checkbox" name="consent" required />
          <label for="consent">I agree to data processing</label>
          <button type="submit">Submit</button>
        </form>
      `;

      const container = document.createElement('div');
      container.innerHTML = compliantHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.filter(v => v.type === 'MISSING_CONSENT_MECHANISM').length).toBe(0);

      container.remove();
    });
  });

  describe('Extension Security Compliance', () => {
    test('should detect excessive permissions', async () => {
      // Mock manifest with excessive permissions
      const originalManifest = chromeMocks.runtime.getManifest;
      chromeMocks.runtime.getManifest.mockReturnValueOnce({
        permissions: ['tabs', 'activeTab', 'webNavigation', 'webRequest', 'webRequestBlocking', 'proxy', 'privacy']
      });

      const container = document.createElement('div');
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'EXCESSIVE_PERMISSIONS')).toBe(true);

      chromeMocks.runtime.getManifest = originalManifest;
      container.remove();
    });

    test('should detect broad host permissions', async () => {
      const originalManifest = chromeMocks.runtime.getManifest;
      chromeMocks.runtime.getManifest.mockReturnValueOnce({
        content_scripts: [{
          matches: ['*://*/*'],
          js: ['content.js']
        }]
      });

      const container = document.createElement('div');
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'BROAD_HOST_PERMISSIONS')).toBe(true);

      chromeMocks.runtime.getManifest = originalManifest;
      container.remove();
    });
  });

  describe('Code Injection Detection', () => {
    test('should detect eval usage', async () => {
      const evalHTML = `
        <script>
          function dangerous(code) {
            return eval(code);
          }
          setTimeout("alert('xss')", 1000);
        </script>
      `;

      const container = document.createElement('div');
      container.innerHTML = evalHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type === 'UNSAFE_CODE_EXECUTION')).toBe(true);

      container.remove();
    });

    test('should detect injection patterns in inputs', async () => {
      const injectionHTML = `
        <input type="text" value="'; DROP TABLE users; --" />
        <textarea>SELECT * FROM users WHERE id = 1 UNION SELECT password FROM admin</textarea>
      `;

      const container = document.createElement('div');
      container.innerHTML = injectionHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.vulnerabilities.some(v => v.type.includes('INJECTION'))).toBe(true);

      container.remove();
    });
  });

  describe('Security Report Generation', () => {
    test('should generate comprehensive security report', async () => {
      const vulnerableHTML = `
        <div>
          <script>document.getElementById('test').innerHTML = userInput;</script>
          <form method="post" action="/submit">
            <input type="text" name="data" />
            <input type="submit" />
          </form>
          <img src="http://example.com/track.gif" />
        </div>
      `;

      const container = document.createElement('div');
      container.innerHTML = vulnerableHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report).toHaveProperty('securityScore');
      expect(report).toHaveProperty('riskLevel');
      expect(report).toHaveProperty('summary');
      expect(report).toHaveProperty('vulnerabilities');
      expect(report).toHaveProperty('recommendations');
      expect(report).toHaveProperty('compliance');

      expect(report.summary.totalVulnerabilities).toBeGreaterThan(0);
      expect(report.recommendations.length).toBeGreaterThan(0);
      expect(report.compliance.owasp.score).toBeDefined();

      container.remove();
    });

    test('should calculate security score correctly', async () => {
      const safeHTML = `
        <div>
          <meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none';">
          <p>Safe content</p>
        </div>
      `;

      const container = document.createElement('div');
      container.innerHTML = safeHTML;
      document.body.appendChild(container);

      const report = await securityFramework.scanForVulnerabilities(container);

      expect(report.securityScore).toBeGreaterThan(80); // Should have high score for safe content
      expect(report.riskLevel).toBe('SECURE');

      container.remove();
    });
  });
});